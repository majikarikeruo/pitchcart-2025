PitchCart 合議MVP 仕様書（発注用）
0. ゴール / スコープ

目的：既存の React/Next.js UI から叩ける 合議型ピッチ分析API を Mastra（TypeScript）で実装する。

差別化要素：

複数ペルソナによる並列評価（擬人化・一人称）

根拠（スライド番号/引用）と確信度

スコアリング（Clarity / Uniqueness / Persuasiveness）

合議サマリー（一致点/対立点/最優先TODO）

軽い改善シミュレーション（what-if：期待上昇値）

非スコープ（今回やらない）：劇場型Q&A、動画/音声解析、外部RAG、複雑な状態管理、DB構築

1. システム構成 / 技術選定

バックエンド：Node.js(>=18) / TypeScript / Mastra（エージェント・ワークフロー）

API層：Next.js API Routes でも Express/Fastify でも可（SSE対応必須）

フロント：既存の React/Next.js（こちら側で対応）

モデル層：LLM クライアントは 抽象化（OpenAI/Anthropic など切替可能に）

観測：最低限のログ（TTFB, total latency, tokens, model, prompt version）

設定：.env でモデル名・APIキー・タイムアウトなどを管理

将来の LangGraph 置換に備え、入出力スキーマとエンドポイント契約を固定すること。

2. API 契約（重要）
2.1 同期エンドポイント

POST /api/analyze

Request

{
  "slides_text": "（スライド全体のテキスト要約 or 抽出結果）",
  "audience_type": "vc|accelerator|user",
  "max_rounds": 1
}


Response

{
  "schema_version": "1.0",
  "personas": [
    {
      "persona_id": "vc_seed",
      "summary": "見送り。最大理由は初期顧客獲得の不明確さ。",
      "scores": { "clarity": 68, "uniqueness": 72, "persuasiveness": 61 },
      "comment": "私はシードのVCだ。Slide3で…（確信度0.7）",
      "evidence": [
        { "slide": 3, "quote": "課題定義が広い" },
        { "slide": 7, "quote": "比較表に定量がない" }
      ],
      "confidence": 0.7
    }
  ],
  "consensus": {
    "agreements": ["結論先出し不足","定量比較が弱い","初期獲得導線が不明確"],
    "disagreements": ["独自性評価（VC高/審査員中）"],
    "overall_score": 67,
    "top_todos": [
      "Slide1に要約（誰に/何を/なぜ今）を追加",
      "競合2社の数値比較表を追記",
      "PoC候補2社の実名と交渉状況を記載"
    ],
    "what_if": [
      { "change": "Slide1要約追加", "expected_gain": 8, "uncertainty": 3 },
      { "change": "定量比較表追加", "expected_gain": 6, "uncertainty": 2 }
    ]
  }
}

2.2 ストリーミング（SSE）

POST /api/analyze/stream

Events

event: message
data: {"type":"persona","data":{...PersonaOutput}}
event: message
data: {"type":"persona","data":{...PersonaOutput}}
event: message
data: {"type":"persona","data":{...PersonaOutput}}
event: message
data: {"type":"consensus","data":{...Consensus}}
event: done
data: {}

3. データスキーマ（厳格）
// schema v1.0
type Score = { clarity: number; uniqueness: number; persuasiveness: number }; // 0..100

type Evidence = { slide?: number; quote?: string };

type PersonaOutput = {
  persona_id: string;          // "vc_seed" | "accelerator_judge" | "early_user" 等
  summary: string;             // 一文の結論
  scores: Score;
  comment: string;             // 一人称・口調固定、根拠と確信度を本文に含めても可
  evidence: Evidence[];        // 最低1個は入れる努力義務
  confidence: number;          // 0..1
};

type Consensus = {
  agreements: string[];        // 1..3
  disagreements: string[];     // 0..2
  overall_score: number;       // 0..100
  top_todos: string[];         // 1..3（行動可能な文）
  what_if?: { change: string; expected_gain: number; uncertainty: number }[];
};

type AnalysisResponse = {
  schema_version: "1.0";
  personas: PersonaOutput[];
  consensus: Consensus;
};


検証：Zod などで JSON バリデーション必須（欠落時は1回だけ自動リペア → 失敗ならフォールバック値で返す）

4. ペルソナ仕様（外部化）

/config/personas.json

[
  {
    "persona_id": "vc_seed",
    "role": "VC（シード/ディープテック寄り）",
    "tone": "端的・厳しめ・事実基調・一人称",
    "weighting": { "clarity": 0.3, "uniqueness": 0.3, "persuasiveness": 0.4 },
    "dealbreakers": ["市場導線が不明", "根拠のない主張"]
  },
  {
    "persona_id": "accelerator_judge",
    "role": "アクセラ審査員",
    "tone": "建設的・実務寄り",
    "weighting": { "clarity": 0.4, "uniqueness": 0.2, "persuasiveness": 0.4 }
  },
  {
    "persona_id": "early_user",
    "role": "アーリーアダプター顧客",
    "tone": "率直・体験重視",
    "weighting": { "clarity": 0.5, "uniqueness": 0.1, "persuasiveness": 0.4 }
  }
]


要件：ペルソナ数は設定で増減できる。UI は返ってきた配列をそのまま描画。

5. プロンプト設計（要点）

System（共通）

「あなたは {role} として評価する。必ず一人称で話す。各主張に根拠（slide番号/引用）と確信度(0-1)を付す。応答は JSON スキーマに厳密準拠。」

User（共通）

スライド要約/抜粋、評価ルーブリック、ペルソナの weighting/tone を渡す

出力

PersonaOutput を function call / json モードで厳密化

合議まとめ

3件の PersonaOutput を渡し、「一致/対立/overall/トップTODO/what_if」を作る（1コール）

6. 実行制御 / パフォーマンス要件

並列実行：ペルソナごとに並列（Promise.allSettled）

タイムアウト：各ペルソナ 10s（設定化）。タイムアウト時はフォールバック PersonaOutput を生成し、合議は続行

モデル：

ペルソナ個別 → 軽量/高速モデル

合議まとめ → やや強いモデル

.env で切替可能に（PERSONA_MODEL, MERGE_MODEL）

SSE：asCompleted で順次送出 → 最後に合議

SLO目安：TTFB < 2s / 全体 < 12s（スライド要約済み前提）

7. エラーハンドリング

JSON検証失敗：自動リペア（プロンプト追記）を最大1回。それでも失敗 → フォールバック PersonaOutput（スコア50/50/50、confidence 0.3、comment に警告）

1人欠席：残り2人 + 合議を返す（disagreements に「データ不足」も可）

全滅：HTTP 200で consensus.top_todos に「再実行を推奨」を入れ、overall_score = 50 を返却（UI崩壊を避ける）

8. セキュリティ / 運用

APIキー：サーバ側のみ保持、フロントへは出さない

CORS：指定ドメインのみ許可

ログ：モデル名/レイテンシ/トークン数/エラー種別/ペルソナID

バージョン：schema_version: "1.0" を必ず返却（将来の互換用）

9. 受け入れ基準（Acceptance Criteria）

 /api/analyze が上記スキーマで 同期レスポンスを返す

 /api/analyze/stream が SSE でペルソナ→合議の順でイベント送出

 ペルソナ数を設定ファイルで増減でき、APIの出力が追従

 1ペルソナが失敗しても 合議が返る

 根拠（slide/quote） が最低1件は含まれる努力義務（無い場合は comment に「根拠不足」を明記）

 .env でモデル切替・タイムアウト変更が可能

 基本ロードで 全体 < 12s（要件を満たすようプロンプト・並列・SSEを調整）

10. テスト観点

ユニット：スキーマ検証、合議ロジック（平均/一致・対立抽出のヒューリスティック）

統合：3ペルソナ成功、1人タイムアウト、全滅、SSE順序

負荷：同時 5〜10 リクエストでSLO内を確認

回帰：ペルソナ設定変更（追加/削除）でレスポンス整合を確認

11. ランディング / 接続

フロントは 既存UI を使用。

fetch('/api/analyze') の同期描画、EventSource('/api/analyze/stream') の逐次描画に対応。

UI アダプター（JSON → 既存 props）の小関数はフロント側で実装。

12. 将来の LangGraph 置換（移行方針）

固定点：本仕様の API入出力 は変更しない

差し替え：runPersonasParallel() と mergeConsensus() を LangGraph の StateGraph に置換

拡張：状態遷移（反論→再評価/人介入/中断再開）を追加しても API契約は維持

メタ情報：LangGraph 導入後は実行トレースIDをレスポンスに追加（meta.trace_id）できるよう余白を残す

13. 納品物

① ソース一式（Mastra/TS）

② .env.sample（必要な環境変数）

③ 起動手順（README）

④ 簡易負荷レポート（SLO達成の確認項目）

⑤ テスト結果（主要ケースのスクショやログ）

補足（依頼時の一言）

「LLM の品質差は求めません。速度と堅牢さ、そして スキーマ厳格 を最優先で。UI は既にあるので、このAPIの契約を守る形でとにかく安定稼働するモジュールを作ってください。後で私が LangGraph へエンジンを差し替えます。」